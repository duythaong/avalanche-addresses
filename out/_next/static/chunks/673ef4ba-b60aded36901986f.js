"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[852],{8928:function(e,t,s){var i=this&&this.__awaiter||function(e,t,s,i){return new(s||(s=Promise))((function(r,o){function n(e){try{d(i.next(e))}catch(t){o(t)}}function a(e){try{d(i.throw(e))}catch(t){o(t)}}function d(e){var t;e.done?r(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(n,a)}d((i=i.apply(e,t||[])).next())}))},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.AVMAPI=void 0;const o=r(s(6141)),n=s(13055),a=r(s(89734)),d=s(77300),h=s(62064),l=s(67715),c=s(47809),u=s(77673),A=s(3421),f=s(98769),g=s(89858),y=s(49009),p=s(77556),T=s(3079),x=a.default.getInstance(),I=T.Serialization.getInstance();class m extends f.JRPCAPI{constructor(e,t="/ext/bc/X",s=""){super(e,t),this.keychain=new l.KeyChain("",""),this.blockchainID="",this.blockchainAlias=void 0,this.AVAXAssetID=void 0,this.txFee=void 0,this.creationTxFee=void 0,this.getBlockchainAlias=()=>{if("undefined"===typeof this.blockchainAlias){const e=this.core.getNetworkID();return e in g.Defaults.network&&this.blockchainID in g.Defaults.network[`${e}`]?(this.blockchainAlias=g.Defaults.network[`${e}`][this.blockchainID].alias,this.blockchainAlias):void 0}return this.blockchainAlias},this.setBlockchainAlias=e=>{this.blockchainAlias=e},this.getBlockchainID=()=>this.blockchainID,this.refreshBlockchainID=e=>{const t=this.core.getNetworkID();return"undefined"===typeof e&&"undefined"!==typeof g.Defaults.network[`${t}`]?(this.blockchainID=g.Defaults.network[`${t}`].X.blockchainID,!0):"string"===typeof e&&(this.blockchainID=e,!0)},this.parseAddress=e=>{const t=this.getBlockchainAlias(),s=this.getBlockchainID();return x.parseAddress(e,s,t,h.AVMConstants.ADDRESSLENGTH)},this.addressFromBuffer=e=>{const t=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID();return I.bufferToType(e,"bech32",this.core.getHRP(),t)},this.getAVAXAssetID=(e=!1)=>i(this,void 0,void 0,(function*(){if("undefined"===typeof this.AVAXAssetID||e){const e=yield this.getAssetDescription(g.PrimaryAssetAlias);this.AVAXAssetID=e.assetID}return this.AVAXAssetID})),this.setAVAXAssetID=e=>{"string"===typeof e&&(e=x.cb58Decode(e)),this.AVAXAssetID=e},this.getDefaultTxFee=()=>this.core.getNetworkID()in g.Defaults.network?new o.default(g.Defaults.network[this.core.getNetworkID()].X.txFee):new o.default(0),this.getTxFee=()=>("undefined"===typeof this.txFee&&(this.txFee=this.getDefaultTxFee()),this.txFee),this.setTxFee=e=>{this.txFee=e},this.getDefaultCreationTxFee=()=>this.core.getNetworkID()in g.Defaults.network?new o.default(g.Defaults.network[this.core.getNetworkID()].X.creationTxFee):new o.default(0),this.getCreationTxFee=()=>("undefined"===typeof this.creationTxFee&&(this.creationTxFee=this.getDefaultCreationTxFee()),this.creationTxFee),this.setCreationTxFee=e=>{this.creationTxFee=e},this.keyChain=()=>this.keychain,this.newKeyChain=()=>{const e=this.getBlockchainAlias();return this.keychain=e?new l.KeyChain(this.core.getHRP(),e):new l.KeyChain(this.core.getHRP(),this.blockchainID),this.keychain},this.checkGooseEgg=(e,t=new o.default(0))=>i(this,void 0,void 0,(function*(){const s=yield this.getAVAXAssetID(),i=t.gt(new o.default(0))?t:e.getOutputTotal(s),r=e.getBurn(s);return!(!r.lte(g.ONEAVAX.mul(new o.default(10)))&&!r.lte(i))})),this.getBalance=(e,t,s=!1)=>i(this,void 0,void 0,(function*(){if("undefined"===typeof this.parseAddress(e))throw new p.AddressError("Error - AVMAPI.getBalance: Invalid address format");const i={address:e,assetID:t,includePartial:s};return(yield this.callMethod("avm.getBalance",i)).data.result})),this.createAddress=(e,t)=>i(this,void 0,void 0,(function*(){const s={username:e,password:t};return(yield this.callMethod("avm.createAddress",s)).data.result.address})),this.createFixedCapAsset=(e,t,s,r,o,n)=>i(this,void 0,void 0,(function*(){const i={name:s,symbol:r,denomination:o,username:e,password:t,initialHolders:n};return(yield this.callMethod("avm.createFixedCapAsset",i)).data.result.assetID})),this.createVariableCapAsset=(e,t,s,r,o,n)=>i(this,void 0,void 0,(function*(){const i={name:s,symbol:r,denomination:o,username:e,password:t,minterSets:n};return(yield this.callMethod("avm.createVariableCapAsset",i)).data.result.assetID})),this.mint=(e,t,s,r,n,a)=>i(this,void 0,void 0,(function*(){let i,d;i="string"!==typeof r?x.cb58Encode(r):r,d="number"===typeof s?new o.default(s):s;const h={username:e,password:t,amount:d,assetID:i,to:n,minters:a};return(yield this.callMethod("avm.mint",h)).data.result.txID})),this.exportKey=(e,t,s)=>i(this,void 0,void 0,(function*(){if("undefined"===typeof this.parseAddress(s))throw new p.AddressError("Error - AVMAPI.exportKey: Invalid address format");const i={username:e,password:t,address:s};return(yield this.callMethod("avm.exportKey",i)).data.result.privateKey})),this.importKey=(e,t,s)=>i(this,void 0,void 0,(function*(){const i={username:e,password:t,privateKey:s};return(yield this.callMethod("avm.importKey",i)).data.result.address})),this.export=(e,t,s,r,o)=>i(this,void 0,void 0,(function*(){const i={username:e,password:t,to:s,amount:r,assetID:o};return(yield this.callMethod("avm.export",i)).data.result.txID})),this.import=(e,t,s,r)=>i(this,void 0,void 0,(function*(){const i={username:e,password:t,to:s,sourceChain:r};return(yield this.callMethod("avm.import",i)).data.result.txID})),this.listAddresses=(e,t)=>i(this,void 0,void 0,(function*(){const s={username:e,password:t};return(yield this.callMethod("avm.listAddresses",s)).data.result.addresses})),this.getAllBalances=e=>i(this,void 0,void 0,(function*(){if("undefined"===typeof this.parseAddress(e))throw new p.AddressError("Error - AVMAPI.getAllBalances: Invalid address format");const t={address:e};return(yield this.callMethod("avm.getAllBalances",t)).data.result.balances})),this.getAssetDescription=e=>i(this,void 0,void 0,(function*(){let t;t="string"!==typeof e?x.cb58Encode(e):e;const s={assetID:t},i=yield this.callMethod("avm.getAssetDescription",s);return{name:i.data.result.name,symbol:i.data.result.symbol,assetID:x.cb58Decode(i.data.result.assetID),denomination:parseInt(i.data.result.denomination,10)}})),this.getTx=e=>i(this,void 0,void 0,(function*(){const t={txID:e};return(yield this.callMethod("avm.getTx",t)).data.result.tx})),this.getTxStatus=e=>i(this,void 0,void 0,(function*(){const t={txID:e};return(yield this.callMethod("avm.getTxStatus",t)).data.result.status})),this.getUTXOs=(e,t,s=0,r,o)=>i(this,void 0,void 0,(function*(){"string"===typeof e&&(e=[e]);const i={addresses:e,limit:s};"undefined"!==typeof r&&r&&(i.startIndex=r),"undefined"!==typeof t&&(i.sourceChain=t);const n=yield this.callMethod("avm.getUTXOs",i),a=new d.UTXOSet;let h=n.data.result.utxos;if(o&&"object"===typeof o){if(this.db.has(o.getName())){const e=this.db.get(o.getName());if(Array.isArray(e)){a.addArray(h);const t=new d.UTXOSet;t.addArray(e),t.mergeByRule(a,o.getMergeRule()),h=t.getAllUTXOStrings()}}this.db.set(o.getName(),h,o.getOverwrite())}return a.addArray(h,!1),n.data.result.utxos=a,n.data.result})),this.buildBaseTx=(e,t,s,r,n,a,d,h=(0,A.UnixNow)(),l=new o.default(0),c=1)=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(r,"buildBaseTx").map((e=>x.stringToAddress(e))),o=this._cleanAddressArray(n,"buildBaseTx").map((e=>x.stringToAddress(e))),A=this._cleanAddressArray(a,"buildBaseTx").map((e=>x.stringToAddress(e)));"string"===typeof s&&(s=x.cb58Decode(s)),d instanceof u.PayloadBase&&(d=d.getPayload());const f=e.buildBaseTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),t,s,i,o,A,this.getTxFee(),yield this.getAVAXAssetID(),d,h,l,c);if(!(yield this.checkGooseEgg(f)))throw new p.GooseEggCheckError("Error - AVMAPI.buildBaseTx:Failed Goose Egg Check");return f})),this.buildNFTTransferTx=(e,t,s,r,n,a,d=(0,A.UnixNow)(),h=new o.default(0),l=1)=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(t,"buildNFTTransferTx").map((e=>x.stringToAddress(e))),o=this._cleanAddressArray(s,"buildNFTTransferTx").map((e=>x.stringToAddress(e))),c=this._cleanAddressArray(r,"buildCreateNFTAssetTx").map((e=>x.stringToAddress(e)));a instanceof u.PayloadBase&&(a=a.getPayload());const A=yield this.getAVAXAssetID();let f=[];"string"===typeof n?f=[n]:Array.isArray(n)&&(f=n);const g=e.buildNFTTransferTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),i,o,c,f,this.getTxFee(),A,a,d,h,l);if(!(yield this.checkGooseEgg(g)))throw new p.GooseEggCheckError("Error - AVMAPI.buildNFTTransferTx:Failed Goose Egg Check");return g})),this.buildImportTx=(e,t,s,r,a,d,h,l=(0,A.UnixNow)(),c=new o.default(0),f=1)=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(r,"buildImportTx").map((e=>x.stringToAddress(e))),o=this._cleanAddressArray(a,"buildImportTx").map((e=>x.stringToAddress(e))),A=this._cleanAddressArray(d,"buildImportTx").map((e=>x.stringToAddress(e)));let g;if("undefined"===typeof s)throw new p.ChainIdError("Error - AVMAPI.buildImportTx: Source ChainID is undefined.");if("string"===typeof s)g=s,s=x.cb58Decode(s);else if(!(s instanceof n.Buffer))throw new p.ChainIdError("Error - AVMAPI.buildImportTx: Invalid destinationChain type: "+typeof s);const y=(yield this.getUTXOs(t,g,0,void 0)).utxos,T=yield this.getAVAXAssetID(),I=y.getAllUTXOs();if(0===I.length)throw new p.NoAtomicUTXOsError("Error - AVMAPI.buildImportTx: No atomic UTXOs to import from "+g+" using addresses: "+t.join(", "));h instanceof u.PayloadBase&&(h=h.getPayload());const m=e.buildImportTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),i,o,A,I,s,this.getTxFee(),T,h,l,c,f);if(!(yield this.checkGooseEgg(m)))throw new p.GooseEggCheckError("Error - AVMAPI.buildImportTx:Failed Goose Egg Check");return m})),this.buildExportTx=(e,t,s,r,a,d,h,l=(0,A.UnixNow)(),c=new o.default(0),f=1,g)=>i(this,void 0,void 0,(function*(){const i={};if(r.map((e=>{i[e.split("-")[0]]=!0})),1!==Object.keys(i).length)throw new p.AddressError("Error - AVMAPI.buildExportTx: To addresses must have the same chainID prefix.");if("undefined"===typeof s)throw new p.ChainIdError("Error - AVMAPI.buildExportTx: Destination ChainID is undefined.");if("string"===typeof s)s=x.cb58Decode(s);else if(!(s instanceof n.Buffer))throw new p.ChainIdError("Error - AVMAPI.buildExportTx: Invalid destinationChain type: "+typeof s);if(32!==s.length)throw new p.ChainIdError("Error - AVMAPI.buildExportTx: Destination ChainID must be 32 bytes in length.");const o=[];r.map((e=>{o.push(x.stringToAddress(e))}));const A=this._cleanAddressArray(a,"buildExportTx").map((e=>x.stringToAddress(e))),y=this._cleanAddressArray(d,"buildExportTx").map((e=>x.stringToAddress(e)));h instanceof u.PayloadBase&&(h=h.getPayload());const T=yield this.getAVAXAssetID();"undefined"===typeof g&&(g=x.cb58Encode(T));const I=e.buildExportTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),t,x.cb58Decode(g),o,A,y,s,this.getTxFee(),T,h,l,c,f);if(!(yield this.checkGooseEgg(I)))throw new p.GooseEggCheckError("Error - AVMAPI.buildExportTx:Failed Goose Egg Check");return I})),this.buildCreateAssetTx=(e,t,s,r,o,n,a,d,l,c=(0,A.UnixNow)())=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(t,"buildCreateAssetTx").map((e=>x.stringToAddress(e))),A=this._cleanAddressArray(s,"buildCreateNFTAssetTx").map((e=>x.stringToAddress(e)));if(l instanceof u.PayloadBase&&(l=l.getPayload()),n.length>h.AVMConstants.SYMBOLMAXLEN)throw new p.SymbolError("Error - AVMAPI.buildCreateAssetTx: Symbols may not exceed length of "+h.AVMConstants.SYMBOLMAXLEN);if(o.length>h.AVMConstants.ASSETNAMELEN)throw new p.NameError("Error - AVMAPI.buildCreateAssetTx: Names may not exceed length of "+h.AVMConstants.ASSETNAMELEN);const f=yield this.getAVAXAssetID(),g=e.buildCreateAssetTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),i,A,r,o,n,a,d,this.getCreationTxFee(),f,l,c);if(!(yield this.checkGooseEgg(g,this.getCreationTxFee())))throw new p.GooseEggCheckError("Error - AVMAPI.buildCreateAssetTx:Failed Goose Egg Check");return g})),this.buildSECPMintTx=(e,t,s,r,o,n,a,d=(0,A.UnixNow)())=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(r,"buildSECPMintTx").map((e=>x.stringToAddress(e))),h=this._cleanAddressArray(o,"buildSECPMintTx").map((e=>x.stringToAddress(e)));a instanceof u.PayloadBase&&(a=a.getPayload());const l=yield this.getAVAXAssetID(),c=e.buildSECPMintTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),t,s,i,h,n,this.getTxFee(),l,a,d);if(!(yield this.checkGooseEgg(c)))throw new p.GooseEggCheckError("Error - AVMAPI.buildSECPMintTx:Failed Goose Egg Check");return c})),this.buildCreateNFTAssetTx=(e,t,s,r,n,a,d,l=(0,A.UnixNow)(),c=new o.default(0))=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(t,"buildCreateNFTAssetTx").map((e=>x.stringToAddress(e))),o=this._cleanAddressArray(s,"buildCreateNFTAssetTx").map((e=>x.stringToAddress(e)));if(d instanceof u.PayloadBase&&(d=d.getPayload()),n.length>h.AVMConstants.ASSETNAMELEN)throw new p.NameError("Error - AVMAPI.buildCreateNFTAssetTx: Names may not exceed length of "+h.AVMConstants.ASSETNAMELEN);if(a.length>h.AVMConstants.SYMBOLMAXLEN)throw new p.SymbolError("Error - AVMAPI.buildCreateNFTAssetTx: Symbols may not exceed length of "+h.AVMConstants.SYMBOLMAXLEN);const A=yield this.getAVAXAssetID(),f=e.buildCreateNFTAssetTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),i,o,r,n,a,this.getCreationTxFee(),A,d,l,c);if(!(yield this.checkGooseEgg(f,this.getCreationTxFee())))throw new p.GooseEggCheckError("Error - AVMAPI.buildCreateNFTAssetTx:Failed Goose Egg Check");return f})),this.buildCreateNFTMintTx=(e,t,s,r,o,n=0,a,d,h=(0,A.UnixNow)())=>i(this,void 0,void 0,(function*(){const i=this._cleanAddressArray(s,"buildCreateNFTMintTx").map((e=>x.stringToAddress(e))),l=this._cleanAddressArray(r,"buildCreateNFTMintTx").map((e=>x.stringToAddress(e)));d instanceof u.PayloadBase&&(d=d.getPayload()),a instanceof u.PayloadBase&&(a=a.getPayload()),"string"===typeof o&&(o=[o]);const c=yield this.getAVAXAssetID();t instanceof y.OutputOwners&&(t=[t]);const A=e.buildCreateNFTMintTx(this.core.getNetworkID(),x.cb58Decode(this.blockchainID),t,i,l,o,n,a,this.getTxFee(),c,d,h);if(!(yield this.checkGooseEgg(A)))throw new p.GooseEggCheckError("Error - AVMAPI.buildCreateNFTMintTx:Failed Goose Egg Check");return A})),this.signTx=e=>e.sign(this.keychain),this.issueTx=e=>i(this,void 0,void 0,(function*(){let t="";if("string"===typeof e)t=e;else if(e instanceof n.Buffer){const s=new c.Tx;s.fromBuffer(e),t=s.toString()}else{if(!(e instanceof c.Tx))throw new p.TransactionError("Error - AVMAPI.issueTx: provided tx is not expected type of string, Buffer, or Tx");t=e.toString()}const s={tx:t.toString()};return(yield this.callMethod("avm.issueTx",s)).data.result.txID})),this.send=(e,t,s,r,n,a,d,h)=>i(this,void 0,void 0,(function*(){let i,l;if("undefined"===typeof this.parseAddress(n))throw new p.AddressError("Error - AVMAPI.send: Invalid address format");i="string"!==typeof s?x.cb58Encode(s):s,l="number"===typeof r?new o.default(r):r;const c={username:e,password:t,assetID:i,amount:l.toString(10),to:n};if("undefined"!==typeof(a=this._cleanAddressArray(a,"send"))&&(c.from=a),"undefined"!==typeof d){if("undefined"===typeof this.parseAddress(d))throw new p.AddressError("Error - AVMAPI.send: Invalid address format");c.changeAddr=d}"undefined"!==typeof h&&(c.memo="string"!==typeof h?x.cb58Encode(h):h);return(yield this.callMethod("avm.send",c)).data.result})),this.sendMultiple=(e,t,s,r,n,a)=>i(this,void 0,void 0,(function*(){let i,d;const h=[];s.forEach((e=>{if("undefined"===typeof this.parseAddress(e.to))throw new p.AddressError("Error - AVMAPI.sendMultiple: Invalid address format");i="string"!==typeof e.assetID?x.cb58Encode(e.assetID):e.assetID,d="number"===typeof e.amount?new o.default(e.amount):e.amount,h.push({to:e.to,assetID:i,amount:d.toString(10)})}));const l={username:e,password:t,outputs:h};if("undefined"!==typeof(r=this._cleanAddressArray(r,"send"))&&(l.from=r),"undefined"!==typeof n){if("undefined"===typeof this.parseAddress(n))throw new p.AddressError("Error - AVMAPI.send: Invalid address format");l.changeAddr=n}"undefined"!==typeof a&&(l.memo="string"!==typeof a?x.cb58Encode(a):a);return(yield this.callMethod("avm.sendMultiple",l)).data.result})),this.buildGenesis=e=>i(this,void 0,void 0,(function*(){const t={genesisData:e};return(yield this.callMethod("avm.buildGenesis",t)).data.result.bytes})),this.blockchainID=s;const r=e.getNetworkID();if(r in g.Defaults.network&&s in g.Defaults.network[`${r}`]){const{alias:e}=g.Defaults.network[`${r}`][`${s}`];this.keychain=new l.KeyChain(this.core.getHRP(),e)}else this.keychain=new l.KeyChain(this.core.getHRP(),s)}_cleanAddressArray(e,t){const s=[],i=this.getBlockchainAlias()?this.getBlockchainAlias():this.getBlockchainID();if(e&&e.length>0)for(let r=0;r<e.length;r++)if("string"===typeof e[`${r}`]){if("undefined"===typeof this.parseAddress(e[`${r}`]))throw new p.AddressError("Error - AVMAPI.${caller}: Invalid address format");s.push(e[`${r}`])}else{const t="bech32";s.push(I.bufferToType(e[`${r}`],t,this.core.getHRP(),i))}return s}}t.AVMAPI=m}}]);